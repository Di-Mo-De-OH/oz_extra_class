## 1. 디자인패턴 
- 디자인 패턴의 원인과 배경
   - 상속만으로 모든걸 대체하기 어렵다<br>
   <img width="200" height="200" alt="스크린샷 2026-01-26 오후 6 42 07" src="https://github.com/user-attachments/assets/43bee175-658e-4ee7-9477-2b0468d7f9f4" />

     
    <br>
    ex) 이러한 상황에서 러버덕을 추가해야 하는데 오리의 소리를 삑삑으로 내기 떄문에 squeak()을 오버라이드 해야하는 문제가 있음<br>
        문제이유<br>
          1. 추후 나무 오리인형 등이 추가돼면 계속 오버라이드를 해야하는 중복 코드 문제가 발생함<br>
          2. 오리 종류,울음 종류,비행 종류 등 상속만으로는 클래스 수가 너무 많아짐<br>
          3. 부모 클라스 Duck의 fly() 구현을 바꾸면 모든 자식에 영향을 미침
    
    - 재발견 비용 감소 : 매번 새로 설계하지 않기   
    - 의사소통 비용 감소 : 어떤 전략으로 갈지에 대한 이야기를 통해 의사소통 시간 단축
    - 유지보수,확장성 개선 : 변화에 강한 구조를 반복해서 쓰기

  ## 2. 객체지향(oop)
  - 추상화(Abstraction)
    - 복잡한 현실에서의 객체를 뽑아 모델로 정의하는 것
      - ex) fly,quack 등의 날기,울기 개념을 행동(인터페이스) 모델링
  - 캡슐화(Encapsulation)
    - 데이터 와 메서드를 묶고, 내부를 숨기며 안전한 사용만 허용
      - ex)부모 클라스(Duck) 내부에 상태,행동을 캡슐화하고 외부에서는 공개 메서드를 통해서만 호출한다.
  - 상속(Inheritance)
    - 기존 클라스를 확장해서 재사용하는 방법
      - ex) 모든 자식 클라스가 공통으로 사용할 수 있는것 만 상속시켜주고 , 다른 부분만 자식이 구현 확장
  - 다형성(Polymorphism)
    - 같은 인터페이스,매서드 호출이지만, 실제 동작은 객체에 따라 달라짐
      - ex) 한개의 함수로 호출 되지만 내부의 함수에 따라 발생되는 행동이 달라짐
     
  ## 3. 전략 패턴
  - 전략구조의 3가지 역활
      1. 전략을 사용하는 객체(Duck)
      2. 행동 규격 (Fly,Sound)
      3. 실제 행동 구현체(FlyStrong,FlyGently...)  
  - 바꿀 수 있는 행동을 따로 뽑아서 객체로 만들고 필요할떄 갈아끼워주는 디자인 패턴
  - 전략패턴은 행동을 분리한다 fly(),quack()을 부모 클라스(Duck)에 넣어두면 예외가 발생할떄 마다 override가 늘어난다.
  - 장점
    1. 오버라이드 지옥 방지
    2. 조합 폭발 방지
    3. 런타임 교체가능 - 실행 중에 전략을 바꿀 수 있다
    4. 기존 코드 수정 없이 전략만 추가 가능하다
  - 단점
    1. 전략 클라스가 늘어날 수 있음
    2. 작은 프로젝트에선 오히려 과할 수 있다
    
  
